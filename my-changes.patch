diff --git a/.github/workflows/build.yml b/.github/workflows/build.yml
index 1d8e20e..8f0f33f 100644
--- a/.github/workflows/build.yml
+++ b/.github/workflows/build.yml
@@ -14,7 +14,7 @@ jobs:
   build:
     runs-on: windows-latest
     steps:
-      - uses: nschloe/action-cached-lfs-checkout@v1
+      - uses: actions/checkout@v4
       # Cache cargo dependencies
       - name: Cache Cargo registry
         uses: actions/cache@v4
@@ -33,10 +33,6 @@ jobs:
         run: cargo install wasm-pack
       - name: Build WASM
         run: wasm-pack build --target web --out-dir dist
-      - name: Copy assets to dist folder
-        run: |
-          mkdir -p dist/assets
-          cp -r assets/* dist/assets/
       - name: Debug Build Output
         run: |
           echo "Debugging build output:"
diff --git a/.github/workflows/cleanup-closed-prs.yml b/.github/workflows/cleanup-closed-prs.yml
deleted file mode 100644
index 47ceaa5..0000000
--- a/.github/workflows/cleanup-closed-prs.yml
+++ /dev/null
@@ -1,46 +0,0 @@
-name: Cleanup Closed PR Deployments
-
-on:
-  workflow_dispatch:  # Allows manual triggering
-
-jobs:
-  cleanup:
-    runs-on: ubuntu-latest
-    steps:
-      - name: Checkout repository
-        uses: actions/checkout@v4
-        with:
-          ref: gh-pages
-          fetch-depth: 0
-
-      - name: Fetch all closed PRs
-        id: fetch-closed-prs
-        run: |
-          # Fetch all closed PRs using the GitHub API
-          CLOSED_PR_NUMBERS=$(curl -s -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
-            "https://api.github.com/repos/${{ github.repository }}/pulls?state=closed" \
-            | jq -r '.[].number' | tr '\n' ' ')  # Replace newlines with spaces
-            
-          # Properly format the output for GitHub Actions
-          echo "closed_pr_numbers=${CLOSED_PR_NUMBERS}" >> $GITHUB_OUTPUT
-  
-      - name: Remove directories for closed PRs
-        run: |
-          # Loop through all PR directories and delete those for closed PRs
-          for PR_DIR in pr-*; do
-            PR_NUMBER=${PR_DIR#pr-}  # Extract PR number from directory name
-            if echo "${{ steps.fetch-closed-prs.outputs.closed_pr_numbers }}" | grep -qw "$PR_NUMBER"; then
-              echo "Removing directory for closed PR: $PR_DIR"
-              rm -rf "$PR_DIR"
-            else
-              echo "PR $PR_NUMBER is not closed. Skipping directory: $PR_DIR"
-            fi
-          done
-
-      - name: Commit and push changes
-        run: |
-          git config --global user.name "github-actions[bot]"
-          git config --global user.email "github-actions[bot]@users.noreply.github.com"
-          git add .
-          git commit -m "Cleanup: Remove directories for closed PRs"
-          git push origin gh-pages
\ No newline at end of file
diff --git a/assets/items/knight_shield.png b/assets/items/knight_shield.png
new file mode 100644
index 0000000..1ab4aa7
--- /dev/null
+++ b/assets/items/knight_shield.png
@@ -0,0 +1,3 @@
+version https://git-lfs.github.com/spec/v1
+oid sha256:83e7cf8a07cf7ce5a3e180249373ace8379bc7d3ec6edb241c59ef863251e3af
+size 4199
diff --git a/assets/items/magic_shield.png b/assets/items/magic_shield.png
new file mode 100644
index 0000000..c82546c
--- /dev/null
+++ b/assets/items/magic_shield.png
@@ -0,0 +1,3 @@
+version https://git-lfs.github.com/spec/v1
+oid sha256:887092a1b9b6143662bc1378ff01d508e06b8f4be35f79aa8d975299becda1df
+size 5127
diff --git a/assets/spells/shield_effect.png b/assets/spells/shield_effect.png
new file mode 100644
index 0000000..1c5bc08
--- /dev/null
+++ b/assets/spells/shield_effect.png
@@ -0,0 +1,3 @@
+version https://git-lfs.github.com/spec/v1
+oid sha256:fef49783730d169f718f44feead0d6d9860bc904be8a2db9c6b21e0968049bfc
+size 24812
diff --git a/src/ai/mod.rs b/src/ai/mod.rs
deleted file mode 100644
index 8a24f8b..0000000
--- a/src/ai/mod.rs
+++ /dev/null
@@ -1,6 +0,0 @@
-mod plugin;
-mod simple_motion;
-pub mod state;
-
-pub use plugin::AIPlugin;
-pub use simple_motion::SimpleMotion;
diff --git a/src/ai/plugin.rs b/src/ai/plugin.rs
deleted file mode 100644
index db20431..0000000
--- a/src/ai/plugin.rs
+++ /dev/null
@@ -1,21 +0,0 @@
-use bevy::prelude::*;
-
-use crate::{
-    ai::{simple_motion, state},
-    labels::sets::InGameSet,
-};
-
-pub struct AIPlugin;
-
-impl Plugin for AIPlugin {
-    fn build(&self, app: &mut App) {
-        app.add_systems(
-            Update,
-            (
-                state::update_state_on_simple_motion_change,
-                simple_motion::to_velocity,
-            )
-                .in_set(InGameSet::Physics),
-        );
-    }
-}
diff --git a/src/ai/state.rs b/src/ai/state.rs
deleted file mode 100644
index 663e6ea..0000000
--- a/src/ai/state.rs
+++ /dev/null
@@ -1,66 +0,0 @@
-use bevy::prelude::*;
-
-use crate::ai::SimpleMotion;
-
-#[derive(Component, Default, PartialEq, Debug, Hash, Eq, Copy, Clone)]
-pub enum ActionState {
-    Attacking,
-    Defeated, //Death Animation
-    Movement,
-    #[default]
-    Idle,
-    Casting,
-}
-
-/// The direction a character faces and aims are not tied to each other in this game
-#[derive(Component, Default, Hash, PartialEq, Eq, Clone, Copy, Debug)]
-pub enum FacingDirection {
-    Up,
-    #[default]
-    Down,
-    Left,
-    Right,
-}
-
-impl FacingDirection {
-    pub fn from_vec2(&self, vec: Vec2) -> Self {
-        match vec.normalize() {
-            v if v.y > 0.5 => Self::Up,
-            v if v.y < -0.5 => Self::Down,
-            v if v.x > 0.5 => Self::Right,
-            v if v.x < -0.5 => Self::Left,
-            _ => *self,
-        }
-    }
-}
-
-/// Represents coordinate where entitiy is aiming, for player this is the cursor
-#[derive(Component, Default)]
-pub struct AimPosition {
-    pub position: Vec2,
-}
-
-pub fn update_state_on_simple_motion_change(
-    mut query: Query<
-        (&SimpleMotion, &mut ActionState, &mut FacingDirection),
-        Changed<SimpleMotion>,
-    >,
-) {
-    for (motion, mut action_state, mut facing_direction) in query.iter_mut() {
-        facing_direction.set_if_neq(FacingDirection::from_vec2(
-            &facing_direction,
-            motion.direction,
-        ));
-
-        //Defeated and Attacking state take priority over walking / idle
-        if *action_state == ActionState::Attacking || *action_state == ActionState::Defeated {
-            continue;
-        } else {
-            if motion.is_moving() {
-                action_state.set_if_neq(ActionState::Movement);
-            } else {
-                action_state.set_if_neq(ActionState::Idle);
-            }
-        }
-    }
-}
diff --git a/src/animation/components.rs b/src/animation/components.rs
index 24a83e9..5c3913a 100644
--- a/src/animation/components.rs
+++ b/src/animation/components.rs
@@ -1,6 +1,6 @@
 use bevy::{prelude::*, utils::HashMap};
 
-use crate::ai::state::{ActionState, FacingDirection};
+use crate::combat::components::ActionState;
 
 #[derive(Component)]
 pub struct AnimationIndices {
@@ -209,3 +209,24 @@ impl DefaultAnimationConfig {
         Timer::from_seconds(animation.frame_duration, TimerMode::Repeating)
     }
 }
+
+#[derive(Component, Default, Hash, PartialEq, Eq, Clone, Copy, Debug)]
+pub enum FacingDirection {
+    Up,
+    #[default]
+    Down,
+    Left,
+    Right,
+}
+
+impl FacingDirection {
+    pub fn from_vec2(&self, vec: Vec2) -> Self {
+        match vec.normalize() {
+            v if v.y > 0.5 => Self::Up,
+            v if v.y < -0.5 => Self::Down,
+            v if v.x > 0.5 => Self::Right,
+            v if v.x < -0.5 => Self::Left,
+            _ => *self,
+        }
+    }
+}
diff --git a/src/animation/plugin.rs b/src/animation/plugin.rs
index 6fdac64..ff30143 100644
--- a/src/animation/plugin.rs
+++ b/src/animation/plugin.rs
@@ -3,7 +3,9 @@ use bevy::prelude::*;
 use crate::labels::sets::InGameSet;
 
 use super::{
-    animate_sprite, spells::on_healing_tome_visual_added, update_animation, DefaultAnimationConfig,
+    animate_sprite,
+    spells::{on_healing_tome_visual_added, on_shield_effect_added},
+    update_animation, DefaultAnimationConfig,
 };
 
 pub struct AnimationPlugin;
@@ -11,13 +13,10 @@ pub struct AnimationPlugin;
 impl Plugin for AnimationPlugin {
     fn build(&self, app: &mut App) {
         app.add_observer(on_healing_tome_visual_added)
+            .add_observer(on_shield_effect_added)
             .add_systems(
                 Update,
-                ((
-                    animate_sprite,
-                    update_animation, //Change animation if components change that dictace updating it
-                ))
-                    .in_set(InGameSet::Simulation),
+                ((animate_sprite, update_animation)).in_set(InGameSet::Simulation),
             )
             .insert_resource(DefaultAnimationConfig::default());
     }
diff --git a/src/animation/spells/mod.rs b/src/animation/spells/mod.rs
index ee3dbba..63abbf5 100644
--- a/src/animation/spells/mod.rs
+++ b/src/animation/spells/mod.rs
@@ -1,3 +1,4 @@
 mod spell_animations;
 
 pub use spell_animations::on_healing_tome_visual_added;
+pub use spell_animations::on_shield_effect_added;
diff --git a/src/animation/spells/spell_animations.rs b/src/animation/spells/spell_animations.rs
index 8140dac..51f1a33 100644
--- a/src/animation/spells/spell_animations.rs
+++ b/src/animation/spells/spell_animations.rs
@@ -3,7 +3,8 @@ use bevy::{prelude::*, sprite::Anchor};
 use crate::{
     animation::{AnimationIndices, AnimationTimer},
     configuration::assets::{SpriteAssets, SpriteSheetLayouts},
-    items::HealingTomeSpellVisualEffect,
+    items::{HealingTomeSpellVisualEffect, ShieldSpellVisualEffect},
+    labels::layer::ZLayer,
 };
 
 pub fn on_healing_tome_visual_added(
@@ -18,7 +19,7 @@ pub fn on_healing_tome_visual_added(
         Sprite {
             image: sprites.tome_of_healing_effect_sprite_sheet.clone(),
             texture_atlas: Some(TextureAtlas {
-                layout: layouts.tome_of_healing_effect.clone(),
+                layout: layouts.spell_effect.clone(),
                 index: 0,
             }),
             anchor: Anchor::Custom(Vec2::new(0.0, 0.10)),
@@ -32,3 +33,31 @@ pub fn on_healing_tome_visual_added(
         AnimationTimer(Timer::from_seconds(0.1, TimerMode::Repeating)),
     ));
 }
+
+pub fn on_shield_effect_added(
+    trigger: Trigger<OnAdd, ShieldSpellVisualEffect>,
+    mut commands: Commands,
+    sprites: Res<SpriteAssets>,
+    layouts: Res<SpriteSheetLayouts>,
+) {
+    let entity = trigger.entity();
+
+    commands.entity(entity).insert((
+        Sprite {
+            image: sprites.shield_effect_sprite_sheet.clone(),
+            texture_atlas: Some(TextureAtlas {
+                layout: layouts.spell_effect.clone(),
+                index: 0,
+            }),
+            anchor: Anchor::Custom(Vec2::new(0.0, 0.10)),
+            ..default()
+        },
+        Transform::from_xyz(0.0, 0.0, ZLayer::WeaponBehindSprite.z()),
+        AnimationIndices {
+            is_one_shot: false,
+            first: 2,
+            last: 7,
+        },
+        AnimationTimer(Timer::from_seconds(0.1, TimerMode::Repeating)),
+    ));
+}
diff --git a/src/animation/update_animation.rs b/src/animation/update_animation.rs
index 38723ef..b22ef4a 100644
--- a/src/animation/update_animation.rs
+++ b/src/animation/update_animation.rs
@@ -1,10 +1,12 @@
 use crate::{
-    ai::state::{ActionState, FacingDirection},
-    animation::{AnimationIndices, AnimationTimer, DefaultAnimationConfig},
+    animation::{AnimationIndices, AnimationTimer},
+    combat::components::ActionState,
 };
 
 use bevy::prelude::*;
 
+use super::{DefaultAnimationConfig, FacingDirection};
+
 pub fn update_animation(
     animation_config: Res<DefaultAnimationConfig>,
     mut query: Query<
diff --git a/src/combat/health.rs b/src/combat/attributes/health.rs
similarity index 100%
rename from src/combat/health.rs
rename to src/combat/attributes/health.rs
diff --git a/src/combat/mana.rs b/src/combat/attributes/mana.rs
similarity index 72%
rename from src/combat/mana.rs
rename to src/combat/attributes/mana.rs
index 26daf65..85cd755 100644
--- a/src/combat/mana.rs
+++ b/src/combat/attributes/mana.rs
@@ -16,7 +16,7 @@ impl Mana {
         }
     }
 
-    /// Optionally uses mana if it can afford it, otherwise returns false if it cost too much
+    /** Optionally uses mana if it can afford it, otherwise returns false if it cost too much */
     pub fn attempt_use_mana(&mut self, cost: &ManaCost) -> bool {
         if self.current_mana >= cost.0 {
             self.current_mana -= cost.0;
@@ -33,11 +33,19 @@ impl Mana {
     }
 }
 
-/// Attach it to projectiles, weapons, spells, etc... if they cost mana to use
+/**
+ * Attach it to projectiles, weapons, spells, etc... if they cost mana to use
+ */
 #[derive(Component, Clone)]
 pub struct ManaCost(pub f32);
 
-/// Regenerates all `Mana` in game based on time elapsed and the given mana instance's regeneration rate
+/**
+ * Attach it to projectiles, weapons, spells, etc... if they cost mana to actively use (e.g. hold down)
+ * rate =  amount lost per second
+ */
+#[derive(Component, Clone)]
+pub struct ManaDrainRate(pub f32);
+
 pub fn regenerate_mana(mut query: Query<&mut Mana>, time: Res<Time>) {
     let delta_time = time.delta_secs();
     for mut mana in query.iter_mut() {
diff --git a/src/combat/attributes/mod.rs b/src/combat/attributes/mod.rs
new file mode 100644
index 0000000..9ae2187
--- /dev/null
+++ b/src/combat/attributes/mod.rs
@@ -0,0 +1,6 @@
+pub mod health;
+pub mod mana;
+
+pub use health::on_healing_event;
+pub use health::Health;
+pub use mana::{Mana, ManaDrainRate};
diff --git a/src/combat/components.rs b/src/combat/components.rs
new file mode 100644
index 0000000..aa8ff82
--- /dev/null
+++ b/src/combat/components.rs
@@ -0,0 +1,15 @@
+use bevy::prelude::*;
+
+#[derive(Component, Default)]
+pub struct AimPosition {
+    pub position: Vec2, // position where entitiy is aiming, for player this is the cursor
+}
+
+#[derive(Component, PartialEq, Debug, Hash, Eq, Copy, Clone)]
+pub enum ActionState {
+    Attacking,
+    Defeated, //Death Animation
+    Movement,
+    Idle,
+    Casting,
+}
diff --git a/src/combat/damage.rs b/src/combat/damage.rs
deleted file mode 100644
index 12bb757..0000000
--- a/src/combat/damage.rs
+++ /dev/null
@@ -1,111 +0,0 @@
-use avian2d::prelude::*;
-
-use bevy::prelude::*;
-use rand::Rng;
-
-use crate::{
-    combat::{
-        health::Health,
-        invulnerable::{HasIFrames, Invulnerable},
-        status_effects::{components::EffectsList, events::ApplyEffect},
-    },
-    configuration::GameCollisionLayer,
-};
-
-#[derive(PartialEq)]
-pub enum DamageSource {
-    Player,
-    Enemy,
-    NPC,
-    Environment,
-}
-
-impl From<DamageSource> for LayerMask {
-    fn from(source: DamageSource) -> Self {
-        match source {
-            DamageSource::Player => GameCollisionLayer::Enemy.to_bits(),
-            DamageSource::Enemy => GameCollisionLayer::Player.to_bits(),
-            DamageSource::NPC => GameCollisionLayer::Enemy.to_bits(),
-            DamageSource::Environment => {
-                // Combine both Player and Enemy layers for Environment
-                GameCollisionLayer::Enemy.to_bits() | GameCollisionLayer::Player.to_bits()
-            }
-        }
-        .into()
-    }
-}
-
-#[derive(Copy, Clone)]
-pub enum Damage {
-    Range((f32, f32)),
-    Single(f32),
-}
-
-#[derive(Event)]
-pub struct AttemptDamageEvent {
-    /// We treat damage as a range with RNG determining which value is dealt
-    pub damage: Damage,
-    /// Not all damage has a "Source" entity, like environmental damage or damage-over-time effects
-    pub damage_source: Option<Entity>,
-}
-
-/// While AttemptDamageEvent is sent any time a damage source interacts with an entity,
-///this event represents when that damage attempt succeeds
-#[derive(Event)]
-pub struct DamageDealtEvent {
-    pub damage: f32,
-}
-
-#[derive(Event)]
-pub struct DefeatedEvent;
-
-pub fn on_damage_event(
-    damage_trigger: Trigger<AttemptDamageEvent>,
-    mut commands: Commands,
-    mut damaged_query: Query<(&mut Health, Option<&HasIFrames>, Option<&Invulnerable>)>,
-    source_query: Query<&EffectsList>,
-) {
-    if let Ok((mut health, has_iframes, invulnerable)) =
-        damaged_query.get_mut(damage_trigger.entity())
-    {
-        if invulnerable.is_some() {
-            return;
-        }
-
-        // Convert `Damage` to raw damage amount
-        let damage = calculate_damage(damage_trigger.damage);
-        health.take_damage(damage);
-
-        // Because AttemptDamageEvent may not result in damage being applied (invulnerable or entity without health)
-        // we send this event for guranteed "X damage has been done". Proper change detection added to bevy would mean this isn't needed
-        commands.trigger_targets(DamageDealtEvent { damage }, damage_trigger.entity());
-
-        // Entities have to "opt-in" to having iframes. Right now that is only the player
-        if let Some(iframes) = has_iframes {
-            commands
-                .entity(damage_trigger.entity())
-                .insert(Invulnerable::new(iframes));
-        }
-
-        if health.hp == 0.0 {
-            commands.trigger_targets(DefeatedEvent, damage_trigger.entity());
-        } else if let Some(source_entity) = damage_trigger.damage_source {
-            // If entity is still alive and damage source exists and has effects list, we apply status effects
-            if let Ok(effects_list) = source_query.get(source_entity) {
-                commands.trigger_targets(
-                    ApplyEffect {
-                        effect: effects_list.effects.clone(),
-                    },
-                    damage_trigger.entity(),
-                );
-            }
-        }
-    }
-}
-
-fn calculate_damage(damage: Damage) -> f32 {
-    match damage {
-        Damage::Range((min, max)) => rand::thread_rng().gen_range(min..max),
-        Damage::Single(amount) => amount,
-    }
-}
diff --git a/src/combat/invulnerable.rs b/src/combat/damage/components.rs
similarity index 52%
rename from src/combat/invulnerable.rs
rename to src/combat/damage/components.rs
index 672f961..c231023 100644
--- a/src/combat/invulnerable.rs
+++ b/src/combat/damage/components.rs
@@ -1,8 +1,12 @@
 use std::time::Duration;
 
+use avian2d::prelude::{LayerMask, PhysicsLayer};
 use bevy::prelude::*;
 
-/// Component to mark whether an entity has iframes when hit
+use crate::configuration::GameCollisionLayer;
+
+// Component to mark whether an entity has iframes when hit
+// Currently only the player has iframes
 #[derive(Component)]
 pub struct HasIFrames {
     // time to be invulnerable when hit
@@ -14,6 +18,7 @@ pub struct HasIFrames {
 pub struct Invulnerable {
     pub total_time: Timer,
     pub flash_timer: Timer,
+    pub is_transparent: bool,
 }
 
 impl Invulnerable {
@@ -28,6 +33,7 @@ impl Invulnerable {
         Self {
             total_time: Timer::new(Duration::from_secs(4), TimerMode::Once),
             flash_timer: Timer::new(Duration::from_millis(5000), TimerMode::Repeating), //Don't flash
+            is_transparent: false,
         }
     }
 }
@@ -37,30 +43,30 @@ impl Default for Invulnerable {
         Self {
             total_time: Timer::new(Duration::from_secs(2), TimerMode::Once),
             flash_timer: Timer::new(Duration::from_millis(200), TimerMode::Repeating),
+            is_transparent: false,
         }
     }
 }
 
-// System to handle invulnerability duration and flashing
-pub fn handle_invulnerability(
-    mut commands: Commands,
-    time: Res<Time>,
-    mut query: Query<(Entity, &mut Invulnerable, &mut Sprite)>,
-) {
-    for (entity, mut invulnerable, mut sprite) in query.iter_mut() {
-        invulnerable.total_time.tick(time.delta());
-        invulnerable.flash_timer.tick(time.delta());
-
-        //  Alternate sprite alpha between 1.0 and 0.1 on flash timer interval
-        if invulnerable.flash_timer.just_finished() {
-            let current_alpha = sprite.color.alpha();
-            sprite.color.set_alpha(1.1 - current_alpha);
-        }
+#[derive(PartialEq)]
+pub enum DamageSource {
+    Player,
+    Enemy,
+    NPC,
+    Environment,
+}
 
-        // Remove invulnerability when timer is finished and ensure sprite is visible
-        if invulnerable.total_time.finished() {
-            sprite.color.set_alpha(1.0);
-            commands.entity(entity).remove::<Invulnerable>();
+impl From<DamageSource> for LayerMask {
+    fn from(source: DamageSource) -> Self {
+        match source {
+            DamageSource::Player => GameCollisionLayer::Enemy.to_bits(),
+            DamageSource::Enemy => GameCollisionLayer::Player.to_bits(),
+            DamageSource::NPC => GameCollisionLayer::Enemy.to_bits(),
+            DamageSource::Environment => {
+                // Combine both Player and Enemy layers for Environment
+                GameCollisionLayer::Enemy.to_bits() | GameCollisionLayer::Player.to_bits()
+            }
         }
+        .into()
     }
 }
diff --git a/src/combat/damage/events.rs b/src/combat/damage/events.rs
new file mode 100644
index 0000000..43e6db9
--- /dev/null
+++ b/src/combat/damage/events.rs
@@ -0,0 +1,19 @@
+use bevy::prelude::*;
+
+#[derive(Event)]
+pub struct AttemptDamageEvent {
+    pub damage: f32,
+    pub damage_source: Option<Entity>, //Not all damage has a "Source" entity, like environmental damage or DoT effects
+}
+
+/**
+ * While AttemptDamageEvent is sent any time a damage source interacts with an entity,
+ * this event represents when that damage attempt succeeds
+ */
+#[derive(Event)]
+pub struct DamageDealtEvent {
+    pub damage: f32,
+}
+
+#[derive(Event)]
+pub struct DefeatedEvent;
diff --git a/src/combat/damage/mod.rs b/src/combat/damage/mod.rs
new file mode 100644
index 0000000..357d095
--- /dev/null
+++ b/src/combat/damage/mod.rs
@@ -0,0 +1,6 @@
+pub mod components;
+pub mod events;
+pub mod plugin;
+pub mod systems;
+
+pub use plugin::DamagePlugin;
diff --git a/src/combat/damage/plugin.rs b/src/combat/damage/plugin.rs
new file mode 100644
index 0000000..e83551a
--- /dev/null
+++ b/src/combat/damage/plugin.rs
@@ -0,0 +1,13 @@
+use bevy::prelude::*;
+
+use crate::{combat::damage::systems::*, labels::sets::InGameSet};
+
+pub struct DamagePlugin;
+
+impl Plugin for DamagePlugin {
+    fn build(&self, app: &mut App) {
+        app.add_systems(Update, handle_invulnerability.in_set(InGameSet::Simulation))
+            .add_observer(on_damage_event)
+            .add_observer(on_remove_invulnerable);
+    }
+}
diff --git a/src/combat/damage/systems.rs b/src/combat/damage/systems.rs
new file mode 100644
index 0000000..ec2b98f
--- /dev/null
+++ b/src/combat/damage/systems.rs
@@ -0,0 +1,99 @@
+use bevy::prelude::*;
+
+use crate::combat::{
+    attributes::health::Health,
+    damage::{
+        components::Invulnerable,
+        events::{AttemptDamageEvent, DefeatedEvent},
+    },
+    status_effects::{components::EffectsList, events::ApplyEffect},
+};
+
+use super::{components::HasIFrames, events::DamageDealtEvent};
+
+pub fn on_damage_event(
+    damage_trigger: Trigger<AttemptDamageEvent>,
+    mut commands: Commands,
+    mut damaged_query: Query<(&mut Health, Option<&HasIFrames>, Option<&Invulnerable>)>,
+    source_query: Query<&EffectsList>,
+) {
+    if let Ok((mut health, has_iframes, invulnerable)) =
+        damaged_query.get_mut(damage_trigger.entity())
+    {
+        if invulnerable.is_some() {
+            return;
+        }
+
+        health.take_damage(damage_trigger.damage);
+
+        commands.trigger_targets(
+            DamageDealtEvent {
+                damage: damage_trigger.damage,
+            },
+            damage_trigger.entity(),
+        );
+
+        // Damage event decides whether the entity becomes invulernable afterwards
+        if let Some(iframes) = has_iframes {
+            commands
+                .entity(damage_trigger.entity())
+                .insert(Invulnerable::new(iframes));
+        }
+
+        if health.hp == 0.0 {
+            commands.trigger_targets(DefeatedEvent, damage_trigger.entity());
+        } else if let Some(source_entity) = damage_trigger.damage_source {
+            // If entity is still alive and damage source exists and has effects list, we apply status effects
+            if let Ok(effects_list) = source_query.get(source_entity) {
+                commands.trigger_targets(
+                    ApplyEffect {
+                        effect: effects_list.effects.clone(),
+                    },
+                    damage_trigger.entity(),
+                );
+            }
+        }
+    }
+}
+
+// System to handle invulnerability duration and flashing
+pub fn handle_invulnerability(
+    mut commands: Commands,
+    time: Res<Time>,
+    mut query: Query<(Entity, &mut Invulnerable, &mut Sprite)>,
+) {
+    for (entity, mut invulnerable, mut sprite) in query.iter_mut() {
+        // Update main invulnerability timer
+        invulnerable.total_time.tick(time.delta());
+
+        // Update flash timer
+        invulnerable.flash_timer.tick(time.delta());
+
+        // Handle flashing
+        if invulnerable.flash_timer.just_finished() {
+            invulnerable.is_transparent = !invulnerable.is_transparent;
+            sprite.color.set_alpha(if invulnerable.is_transparent {
+                0.1
+            } else {
+                1.0
+            });
+        }
+
+        // Remove invulnerability when timer is finished
+        if invulnerable.total_time.finished() {
+            commands.entity(entity).remove::<Invulnerable>();
+        }
+    }
+}
+
+pub fn on_remove_invulnerable(
+    trigger: Trigger<OnRemove, Invulnerable>,
+    mut query: Query<&mut Sprite>,
+) {
+    // Ensure sprite is fully visible when invulnerability is removed
+    query
+        .get_mut(trigger.entity())
+        .unwrap()
+        .color
+        .set_alpha(1.0);
+}
diff --git a/src/combat/melee/components.rs b/src/combat/melee/components.rs
new file mode 100644
index 0000000..99104dd
--- /dev/null
+++ b/src/combat/melee/components.rs
@@ -0,0 +1,56 @@
+use avian2d::prelude::*;
+use bevy::{prelude::*, utils::HashSet};
+use rand::Rng;
+
+use crate::{
+    combat::{damage::components::DamageSource, status_effects::components::EffectsList},
+    configuration::GameCollisionLayer,
+};
+
+//Repesent a melee weapon
+#[derive(Component, Clone)]
+pub struct MeleeWeapon {
+    pub attack_duration: Timer,
+    pub damage: (f32, f32),
+    pub hitbox: Collider,
+    pub effects_list: EffectsList,
+    pub attack_type: MeleeSwingType,
+}
+
+impl MeleeWeapon {
+    /// Gets collision layers for melee weapon based on source of damage
+    ///
+    /// This is meant to be added when the weapon is equipped.
+    /// We consider melee weapons "Grounded" so they can be used to break chests, etc... on the ground
+    pub fn collision_layers(damage_source: DamageSource) -> CollisionLayers {
+        CollisionLayers::new(GameCollisionLayer::Grounded, LayerMask::from(damage_source))
+    }
+}
+
+#[derive(Debug, Clone)]
+pub enum MeleeSwingType {
+    Stab { speed: f32 },
+    Slash { radius: f32 },
+}
+
+impl MeleeSwingType {
+    pub fn stab() -> Self {
+        MeleeSwingType::Stab { speed: 10.0 }
+    }
+
+    pub fn slash() -> Self {
+        MeleeSwingType::Slash { radius: 25.0 }
+    }
+}
+
+#[derive(Component)]
+#[require(CollidingEntities, Sensor)]
+pub struct ActiveMeleeAttack {
+    pub initial_angle: f32,
+    pub entities_damaged: HashSet<Entity>,
+}
+
+pub fn calculate_damage(damage_range: (f32, f32)) -> f32 {
+    let mut rng = rand::thread_rng();
+    rng.gen_range(damage_range.0..damage_range.1)
+}
diff --git a/src/combat/melee/handle_collisions.rs b/src/combat/melee/handle_collisions.rs
new file mode 100644
index 0000000..2315fe0
--- /dev/null
+++ b/src/combat/melee/handle_collisions.rs
@@ -0,0 +1,44 @@
+use avian2d::prelude::*;
+use bevy::prelude::*;
+
+use crate::{combat::damage::events::AttemptDamageEvent, enemy::Enemy, player::Player};
+
+use super::components::{calculate_damage, ActiveMeleeAttack, MeleeWeapon};
+
+pub fn handle_melee_collisions(
+    mut commands: Commands,
+    mut melee_query: Query<(
+        Entity,
+        &MeleeWeapon,
+        &mut ActiveMeleeAttack,
+        &CollidingEntities,
+    )>,
+    enemy_query: Query<&Enemy>,
+    player: Single<Entity, With<Player>>,
+) {
+    let player_entity = player.into_inner();
+
+    for (weapon_entity, melee_weapon, mut active_melee_attack, colliding_entities) in
+        melee_query.iter_mut()
+    {
+        for &colliding_entity in colliding_entities.iter() {
+            if (enemy_query.contains(colliding_entity) || colliding_entity == player_entity)
+                && (!active_melee_attack
+                    .entities_damaged
+                    .contains(&colliding_entity))
+            {
+                let damage = calculate_damage(melee_weapon.damage);
+                commands.trigger_targets(
+                    AttemptDamageEvent {
+                        damage,
+                        damage_source: Some(weapon_entity),
+                    },
+                    colliding_entity,
+                );
+                active_melee_attack
+                    .entities_damaged
+                    .insert(colliding_entity);
+            }
+        }
+    }
+}
diff --git a/src/combat/melee/mod.rs b/src/combat/melee/mod.rs
index b401ed2..fe7b62b 100644
--- a/src/combat/melee/mod.rs
+++ b/src/combat/melee/mod.rs
@@ -1,47 +1,3 @@
-use avian2d::prelude::*;
-use bevy::prelude::*;
-
-use crate::{
-    combat::{damage::DamageSource, status_effects::components::EffectsList},
-    configuration::GameCollisionLayer,
-};
-
-mod melee_attack;
-
-pub use melee_attack::*;
-
-//Repesent a melee weapon
-#[derive(Component, Clone)]
-pub struct MeleeWeapon {
-    pub attack_duration: Timer,
-    pub damage: (f32, f32),
-    pub hitbox: Collider,
-    pub effects_list: EffectsList,
-    pub attack_type: MeleeSwingType,
-}
-
-impl MeleeWeapon {
-    /// Gets collision layers for melee weapon based on source of damage
-    ///
-    /// This is meant to be added when the weapon is equipped.
-    /// We consider melee weapons "Grounded" so they can be used to break chests, etc... on the ground
-    pub fn collision_layers(damage_source: DamageSource) -> CollisionLayers {
-        CollisionLayers::new(GameCollisionLayer::Grounded, LayerMask::from(damage_source))
-    }
-}
-
-#[derive(Debug, Clone)]
-pub enum MeleeSwingType {
-    Stab { speed: f32 },
-    Slash { radius: f32 },
-}
-
-impl MeleeSwingType {
-    pub fn stab() -> Self {
-        MeleeSwingType::Stab { speed: 10.0 }
-    }
-
-    pub fn slash() -> Self {
-        MeleeSwingType::Slash { radius: 25.0 }
-    }
-}
+pub mod components;
+pub mod handle_collisions;
+pub mod swing_melee_attacks;
diff --git a/src/combat/melee/melee_attack.rs b/src/combat/melee/swing_melee_attacks.rs
similarity index 67%
rename from src/combat/melee/melee_attack.rs
rename to src/combat/melee/swing_melee_attacks.rs
index 1a578d4..b46f5b0 100644
--- a/src/combat/melee/melee_attack.rs
+++ b/src/combat/melee/swing_melee_attacks.rs
@@ -1,23 +1,10 @@
-use avian2d::prelude::*;
-use bevy::{prelude::*, utils::HashSet};
-
 use crate::{
-    ai::state::{ActionState, FacingDirection},
-    combat::{
-        damage::{AttemptDamageEvent, Damage},
-        melee::{MeleeSwingType, MeleeWeapon},
-    },
-    enemy::Enemy,
+    animation::FacingDirection, combat::components::ActionState,
     items::equipment::EquipmentTransform,
-    player::Player,
 };
 
-#[derive(Component)]
-#[require(CollidingEntities, Sensor)]
-pub struct ActiveMeleeAttack {
-    pub initial_angle: f32,
-    pub entities_damaged: HashSet<Entity>,
-}
+use super::components::{ActiveMeleeAttack, MeleeSwingType, MeleeWeapon};
+use bevy::{prelude::*, utils::HashSet};
 
 pub fn start_melee_attack(
     commands: &mut Commands,
@@ -40,7 +27,8 @@ pub fn end_melee_attacks(
     for (entity, parent, melee_weapon, mut transform) in query.iter_mut() {
         if melee_weapon.attack_duration.just_finished() {
             if let Ok(mut action_state) = action_state_query.get_mut(parent.get()) {
-                // This handles the edge case of dying mid-swing
+                //Handle the edge case of
+                //Dying mid melee swing
                 if *action_state != ActionState::Defeated {
                     *action_state = ActionState::Movement;
                     *transform = EquipmentTransform::get(FacingDirection::Down).mainhand;
@@ -105,40 +93,3 @@ pub fn process_melee_attacks(
         }
     }
 }
-
-pub fn handle_melee_collisions(
-    mut commands: Commands,
-    mut melee_query: Query<(
-        Entity,
-        &MeleeWeapon,
-        &mut ActiveMeleeAttack,
-        &CollidingEntities,
-    )>,
-    enemy_query: Query<&Enemy>,
-    player: Single<Entity, With<Player>>,
-) {
-    let player_entity = player.into_inner();
-
-    for (weapon_entity, melee_weapon, mut active_melee_attack, colliding_entities) in
-        melee_query.iter_mut()
-    {
-        for &colliding_entity in colliding_entities.iter() {
-            if (enemy_query.contains(colliding_entity) || colliding_entity == player_entity)
-                && (!active_melee_attack
-                    .entities_damaged
-                    .contains(&colliding_entity))
-            {
-                commands.trigger_targets(
-                    AttemptDamageEvent {
-                        damage: Damage::Range(melee_weapon.damage),
-                        damage_source: Some(weapon_entity),
-                    },
-                    colliding_entity,
-                );
-                active_melee_attack
-                    .entities_damaged
-                    .insert(colliding_entity);
-            }
-        }
-    }
-}
diff --git a/src/combat/mod.rs b/src/combat/mod.rs
index af3373e..2ec491c 100644
--- a/src/combat/mod.rs
+++ b/src/combat/mod.rs
@@ -1,11 +1,9 @@
+pub mod attributes;
+pub mod components;
 pub mod damage;
-pub mod health;
-pub mod invulnerable;
-pub mod mana;
 pub mod melee;
 pub mod plugin;
 pub mod projectile;
+pub mod shield;
 pub mod status_effects;
-
-pub use health::Health;
-pub use mana::Mana;
+pub mod weapon;
diff --git a/src/combat/plugin.rs b/src/combat/plugin.rs
index d85577c..9b6f56f 100644
--- a/src/combat/plugin.rs
+++ b/src/combat/plugin.rs
@@ -2,35 +2,42 @@ use bevy::prelude::*;
 
 use crate::{
     combat::{
-        damage, health, invulnerable, mana, melee, projectile,
+        attributes::mana::*, damage::DamagePlugin, projectile::handle_collisions::*,
         status_effects::plugin::StatusEffectPlugin,
     },
     labels::sets::InGameSet,
 };
 
+use super::{
+    attributes::on_healing_event,
+    melee::{
+        handle_collisions::handle_melee_collisions,
+        swing_melee_attacks::{end_melee_attacks, process_melee_attacks},
+    },
+    shield::{
+        handle_collisions::handle_projectile_reflection_collisions,
+        shield_block::{activate_shield, update_active_shields},
+    },
+};
+
 pub struct CombatPlugin;
 
 impl Plugin for CombatPlugin {
     fn build(&self, app: &mut App) {
-        app.add_plugins(StatusEffectPlugin)
+        app.add_plugins((DamagePlugin, StatusEffectPlugin))
             .add_systems(
                 Update,
                 (
-                    (
-                        invulnerable::handle_invulnerability,
-                        mana::regenerate_mana,
-                        melee::process_melee_attacks,
-                    )
-                        .in_set(InGameSet::Simulation),
-                    (
-                        melee::end_melee_attacks,
-                        projectile::handle_projectile_collisions,
-                        melee::handle_melee_collisions,
-                    )
-                        .in_set(InGameSet::Collision),
+                    regenerate_mana.in_set(InGameSet::Simulation),
+                    process_melee_attacks.in_set(InGameSet::Simulation),
+                    end_melee_attacks.in_set(InGameSet::Collision),
+                    handle_projectile_reflection_collisions.in_set(InGameSet::Collision),
+                    handle_projectile_collisions.in_set(InGameSet::Collision),
+                    handle_melee_collisions.in_set(InGameSet::Collision),
+                    update_active_shields.in_set(InGameSet::Simulation),
                 ),
             )
-            .add_observer(health::on_healing_event)
-            .add_observer(damage::on_damage_event);
+            .add_observer(on_healing_event)
+            .add_observer(activate_shield);
     }
 }
diff --git a/src/combat/projectile/components.rs b/src/combat/projectile/components.rs
index d07a59d..bc7c9db 100644
--- a/src/combat/projectile/components.rs
+++ b/src/combat/projectile/components.rs
@@ -1,16 +1,17 @@
 use avian2d::prelude::*;
 use bevy::prelude::*;
+use rand::Rng;
 
 use crate::{combat::status_effects::components::EffectsList, despawn::components::LiveDuration};
 
-#[derive(Bundle, Clone)]
+#[derive(Bundle, Debug, Clone)]
 pub struct ProjectileBundle {
     pub projectile: Projectile,
     pub sprite: Sprite,
     pub effects_list: EffectsList,
 }
 
-#[derive(Component, Clone)]
+#[derive(Component, Debug, Clone)]
 #[require(
     LiveDuration(|| LiveDuration::new(1.0)),
     Sensor,
@@ -29,3 +30,8 @@ fn default_collider() -> Collider {
 fn default_rigid_body() -> RigidBody {
     RigidBody::Dynamic
 }
+
+pub fn calculate_damage(damage_range: (f32, f32)) -> f32 {
+    let mut rng = rand::thread_rng();
+    rng.gen_range(damage_range.0..damage_range.1)
+}
diff --git a/src/combat/projectile/handle_collisions.rs b/src/combat/projectile/handle_collisions.rs
index 90a93bc..1f35923 100644
--- a/src/combat/projectile/handle_collisions.rs
+++ b/src/combat/projectile/handle_collisions.rs
@@ -2,9 +2,7 @@ use avian2d::prelude::*;
 use bevy::prelude::*;
 
 use crate::combat::{
-    damage::{AttemptDamageEvent, Damage},
-    projectile::components::*,
-    Health,
+    attributes::Health, damage::events::AttemptDamageEvent, projectile::components::*,
 };
 
 pub fn handle_projectile_collisions(
@@ -16,9 +14,10 @@ pub fn handle_projectile_collisions(
         for &colliding_entity in colliding_entities.iter() {
             // If the thing we collide with has health, lets try to damage it!
             if health_query.contains(colliding_entity) {
+                let damage = calculate_damage(projectile.damage);
                 commands.trigger_targets(
                     AttemptDamageEvent {
-                        damage: Damage::Range(projectile.damage),
+                        damage,
                         damage_source: Some(projectile_entity),
                     },
                     colliding_entity,
diff --git a/src/combat/projectile/mod.rs b/src/combat/projectile/mod.rs
index 390c26c..59d070a 100644
--- a/src/combat/projectile/mod.rs
+++ b/src/combat/projectile/mod.rs
@@ -1,7 +1,6 @@
 pub mod components;
-mod handle_collisions;
-mod projectile_weapon;
+pub mod handle_collisions;
 pub mod spawn;
 
-pub use handle_collisions::handle_projectile_collisions;
-pub use projectile_weapon::ProjectileWeapon;
+//Used for spell reflection code
+pub use spawn::spawn_projectile;
diff --git a/src/combat/projectile/spawn.rs b/src/combat/projectile/spawn.rs
index 9c6293f..4f24c3b 100644
--- a/src/combat/projectile/spawn.rs
+++ b/src/combat/projectile/spawn.rs
@@ -1,47 +1,101 @@
-use avian2d::prelude::*;
-use bevy::prelude::*;
-
+use super::components::Projectile;
 use crate::{
     animation::{AnimationIndices, AnimationTimer},
-    combat::{damage::DamageSource, projectile::projectile_weapon::ProjectileWeapon},
+    combat::{
+        damage::components::DamageSource, status_effects::components::EffectsList,
+        weapon::weapon::ProjectileWeapon,
+    },
     configuration::GameCollisionLayer,
+    labels::layer::ZLayer,
 };
+use avian2d::prelude::*;
+use bevy::prelude::*;
 
-pub fn spawn_projectile(
-    damage_source: DamageSource, //Player, enemy, NPC, Party Member
+pub fn spawn_projectile_from_weapon(
+    damage_source: DamageSource,
     commands: &mut Commands,
     caster_transform: &Transform,
-    caster_aim_position: Vec2,
+    aim_position: Vec2,
     weapon: &ProjectileWeapon,
+) {
+    let position = caster_transform.translation;
+    let velocity = (aim_position - position.truncate()).normalize() * weapon.projectile_speed;
+
+    spawn_projectile(
+        damage_source,
+        commands,
+        position,
+        velocity,
+        &weapon.projectile.projectile,
+        &weapon.projectile.sprite,
+        &weapon.projectile.effects_list,
+    );
+}
+
+pub fn spawn_projectile(
+    damage_source: DamageSource,
+    commands: &mut Commands,
+    position: Vec3,
+    velocity: Vec2,
+    projectile: &Projectile,
+    sprite: &Sprite,
+    effects_list: &EffectsList,
 ) {
     let mut transform = Transform {
-        translation: caster_transform.translation,
+        translation: Vec3::new(position.x, position.y, ZLayer::Projectiles.z()),
         ..default()
     };
 
-    let caster_direction = caster_transform.local_x().truncate();
-    let aim_direction = caster_aim_position - caster_transform.translation.truncate();
-    let angle = caster_direction.angle_to(aim_direction);
-
-    transform.rotate_z(angle);
-
-    let velocity = aim_direction.normalize() * weapon.projectile_speed;
-
-    trace!("Spawning projectile w/ velocity: {}", velocity);
-
-    commands.spawn((
-        weapon.projectile.clone(),
-        transform,
-        LinearVelocity(velocity),
-        AnimationIndices {
-            first: 0,
-            last: 4,
-            is_one_shot: false,
-        },
-        AnimationTimer(Timer::from_seconds(0.2, TimerMode::Repeating)),
-        CollisionLayers::new(
-            GameCollisionLayer::InAir,
-            LayerMask::from(damage_source) | GameCollisionLayer::HighObstacle,
-        ),
-    ));
+    transform.look_to(Vec3::new(velocity.x, velocity.y, 0.0), Vec3::Z);
+
+    let entity = commands
+        .spawn((
+            projectile.clone(),
+            transform,
+            LinearVelocity(velocity),
+            sprite.clone(),
+            effects_list.clone(),
+            AnimationIndices {
+                first: 0,
+                last: 4,
+                is_one_shot: false,
+            },
+            AnimationTimer(Timer::from_seconds(0.2, TimerMode::Repeating)),
+            CollisionLayers::new(
+                GameCollisionLayer::InAir,
+                LayerMask::from(damage_source) | GameCollisionLayer::HighObstacle,
+            ),
+        ))
+        .id();
+}
+
+pub fn spawn_reflected_projectile(
+    damage_source: DamageSource,
+    commands: &mut Commands,
+    original_projectile: &Projectile,
+    original_sprite: &Sprite,
+    effects_list: &EffectsList,
+    impact_position: Vec3,
+    incoming_velocity: Vec2,
+) {
+    if incoming_velocity.length() <= 0.001 {
+        error!(
+            "CRITICAL ERROR: Incoming velocity is zero or near-zero: {:?}",
+            incoming_velocity
+        );
+        return;
+    }
+
+    let reflection_direction = -incoming_velocity.normalize(); // Reverse the velocity
+    let reflected_velocity = reflection_direction * incoming_velocity.length();
+
+    spawn_projectile(
+        damage_source,
+        commands,
+        impact_position,
+        reflected_velocity,
+        original_projectile,
+        original_sprite,
+        effects_list,
+    );
 }
diff --git a/src/combat/shield/components.rs b/src/combat/shield/components.rs
new file mode 100644
index 0000000..bce183c
--- /dev/null
+++ b/src/combat/shield/components.rs
@@ -0,0 +1,18 @@
+use avian2d::prelude::{CollidingEntities, CollisionLayers, Sensor};
+use bevy::prelude::*;
+
+use crate::configuration::GameCollisionLayer;
+
+#[derive(Component, Default)]
+#[require(CollidingEntities, Sensor)]
+pub struct ProjectileReflection;
+
+impl ProjectileReflection {
+    pub fn collision_layers() -> CollisionLayers {
+        //TODO: Shield PR:  Need a layer mask
+        CollisionLayers::new(GameCollisionLayer::HighObstacle, GameCollisionLayer::InAir)
+    }
+}
+
+#[derive(Component)]
+pub struct ActiveShield;
diff --git a/src/combat/shield/handle_collisions.rs b/src/combat/shield/handle_collisions.rs
new file mode 100644
index 0000000..0a1cda5
--- /dev/null
+++ b/src/combat/shield/handle_collisions.rs
@@ -0,0 +1,89 @@
+use crate::{
+    combat::{
+        damage::components::DamageSource,
+        projectile::{components::*, spawn::spawn_reflected_projectile, spawn_projectile},
+        shield::components::ProjectileReflection,
+        status_effects::components::EffectsList,
+        weapon::weapon::ProjectileWeapon,
+    },
+    items::equipment::Equipped,
+};
+use avian2d::prelude::*;
+use bevy::prelude::*;
+
+pub fn handle_projectile_reflection_collisions(
+    mut commands: Commands,
+    projectile_reflector_query: Query<(
+        &ProjectileReflection,
+        &CollidingEntities,
+        Entity,
+        &Transform,
+    )>,
+    projectile_query: Query<(
+        &Projectile,
+        &Transform,
+        &LinearVelocity,
+        &Sprite,
+        &EffectsList,
+        Entity,
+    )>,
+    equipped_query: Query<&Equipped>,
+    // Add parent transform query to get the parent/caster's position
+    parent_query: Query<&Transform>,
+) {
+    for (_, colliding_entities, reflector_entity, reflector_transform) in
+        projectile_reflector_query.iter()
+    {
+        let shield_owner = match equipped_query.get(reflector_entity) {
+            Ok(equipped) => equipped.get_equipped_to(),
+            Err(_) => continue, // Skip if not equipped
+        };
+
+        // Get the caster/owner transform
+        let caster_transform = match parent_query.get(shield_owner) {
+            Ok(transform) => transform,
+            Err(_) => {
+                warn!(
+                    "Could not find caster transform for shield owner: {:?}",
+                    shield_owner
+                );
+                continue; // Skip if we can't get the caster transform
+            }
+        };
+
+        info!("Shield owner position: {:?}", caster_transform.translation);
+        info!("Shield position: {:?}", reflector_transform.translation);
+
+        for &colliding_entity in colliding_entities.iter() {
+            if let Ok((
+                projectile,
+                projectile_transform,
+                linear_velocity,
+                sprite,
+                effects_list,
+                _,
+            )) = projectile_query.get(colliding_entity)
+            {
+                info!("Reflecting projectile!");
+
+                // Pass both shield position and caster position to the reflection function
+                let impact_position =
+                    reflector_transform.translation + caster_transform.translation;
+                let incoming_velocity = linear_velocity.0;
+                let new_damage_source = DamageSource::Player;
+
+                spawn_reflected_projectile(
+                    new_damage_source,
+                    &mut commands,
+                    projectile,
+                    sprite,
+                    effects_list,
+                    impact_position,
+                    incoming_velocity,
+                );
+
+                commands.entity(colliding_entity).despawn_recursive();
+            }
+        }
+    }
+}
diff --git a/src/combat/shield/mod.rs b/src/combat/shield/mod.rs
new file mode 100644
index 0000000..0603825
--- /dev/null
+++ b/src/combat/shield/mod.rs
@@ -0,0 +1,5 @@
+pub mod components;
+pub mod handle_collisions;
+pub mod shield_block;
+
+pub use components::ActiveShield;
diff --git a/src/combat/shield/shield_block.rs b/src/combat/shield/shield_block.rs
new file mode 100644
index 0000000..339e080
--- /dev/null
+++ b/src/combat/shield/shield_block.rs
@@ -0,0 +1,145 @@
+use crate::{
+    animation::FacingDirection,
+    combat::{
+        attributes::{Mana, ManaDrainRate},
+        components::AimPosition,
+    },
+    items::{
+        equipment::{EquipmentTransform, Equipped},
+        Shield,
+    },
+    labels::layer::ZLayer,
+};
+use avian2d::prelude::{Collider, CollisionLayers};
+use bevy::prelude::*;
+use std::f32::consts::{FRAC_PI_2, FRAC_PI_4, PI};
+
+use super::{components::ProjectileReflection, ActiveShield};
+
+pub fn update_active_shields(
+    mut commands: Commands,
+    time: Res<Time>,
+    active_shields: Query<(Entity, &Shield, &ManaDrainRate, &ActiveShield)>,
+    mut sprites: Query<&mut Sprite>,
+    transforms: Query<&Transform>,
+    equipped: Query<&Equipped>,
+    holder_query: Query<(&Transform, &AimPosition, &FacingDirection)>,
+    mut mana_query: Query<&mut Mana>,
+) {
+    for (shield_entity, shield, mana_drain_rate, shield_state) in active_shields.iter() {
+        // Get the holder of this shield
+        let Ok(equipped_info) = equipped.get(shield_entity) else {
+            continue;
+        };
+        let holder_entity = equipped_info.get_equipped_to();
+
+        // Update shield position
+        let Ok((holder_transform, aim_pos, facing_direction)) = holder_query.get(holder_entity)
+        else {
+            continue;
+        };
+        let holder_pos = holder_transform.translation.truncate();
+        let aim_direction: Vec2 = (aim_pos.position - holder_pos).normalize();
+        let block_angle = aim_direction.y.atan2(aim_direction.x) + FRAC_PI_2;
+
+        // Get shield components for updating
+        let Ok(shield_transform) = transforms.get(shield_entity) else {
+            continue;
+        };
+        let Ok(mut shield_sprite) = sprites.get_mut(shield_entity) else {
+            continue;
+        };
+
+        // Normalize the angle to be between -PI and PI
+        let normalized_angle = if block_angle < -PI {
+            block_angle + 2.0 * PI
+        } else if block_angle > PI {
+            block_angle - 2.0 * PI
+        } else {
+            block_angle
+        };
+
+        // Determine atlas index based on angle quadrants using PI constants
+        let atlas_index = if normalized_angle > -FRAC_PI_4 && normalized_angle < FRAC_PI_4 {
+            0
+        } else if normalized_angle >= -3.0 * FRAC_PI_4 && normalized_angle <= -FRAC_PI_4 {
+            2
+        } else if (normalized_angle <= -3.0 * FRAC_PI_4) || (normalized_angle >= 3.0 * FRAC_PI_4) {
+            3
+        } else {
+            1
+        };
+
+        let offset_distance = 40.0;
+        let position_offset = Vec3::new(
+            offset_distance * normalized_angle.sin(),  // X coordinate
+            -offset_distance * normalized_angle.cos(), // Y coordinate (negative because Y is inverted)
+            if atlas_index == 0 {
+                ZLayer::WeaponAboveSprite.z()
+            } else {
+                ZLayer::WeaponBehindSprite.z()
+            },
+        );
+
+        // Update the sprite texture atlas index
+        if let Some(atlas) = &mut shield_sprite.texture_atlas {
+            atlas.index = atlas_index;
+        }
+
+        // Set the transform
+        commands.entity(shield_entity).insert(Transform::from_xyz(
+            position_offset.x,
+            position_offset.y,
+            position_offset.z,
+        ));
+
+        // Drain mana
+        if let Ok(mut mana) = mana_query.get_mut(holder_entity) {
+            //This is wrong, drain amount should = drain rate when delta time is exactly 1 frame long
+            let drain_amount = mana_drain_rate.0 * time.delta_secs();
+            if mana.current_mana < drain_amount {
+                deactivate_shield(
+                    &mut commands,
+                    shield_entity,
+                    *facing_direction,
+                    Some(&mut shield_sprite),
+                );
+            } else {
+                mana.current_mana -= drain_amount;
+            }
+        }
+    }
+}
+
+pub fn deactivate_shield(
+    commands: &mut Commands,
+    shield_entity: Entity,
+    facing_direction: FacingDirection,
+    shield_sprite: Option<&mut Sprite>,
+) {
+    commands
+        .entity(shield_entity)
+        .remove::<ActiveShield>()
+        .remove::<Collider>()
+        .insert(EquipmentTransform::get(facing_direction).offhand);
+
+    if let Some(sprite) = shield_sprite {
+        if let Some(atlas) = &mut sprite.texture_atlas {
+            atlas.index = 0;
+        }
+    }
+}
+pub fn activate_shield(
+    trigger: Trigger<OnAdd, ActiveShield>,
+    mut commands: Commands,
+    shield_query: Query<&Shield>,
+) {
+    if let Ok(activated_shield) = shield_query.get(trigger.entity()) {
+        commands
+            .entity(trigger.entity())
+            .insert(activated_shield.hitbox.clone())
+            .insert(ProjectileReflection::collision_layers());
+    } else {
+        warn!("Active Shield added to something that isn't a shield");
+    }
+}
diff --git a/src/combat/status_effects/components.rs b/src/combat/status_effects/components.rs
index baaac19..7102b3a 100644
--- a/src/combat/status_effects/components.rs
+++ b/src/combat/status_effects/components.rs
@@ -7,12 +7,12 @@ use super::events::ApplyStatus;
 /**
  * "Effects" are currently just a list of statuses to apply
  */
-#[derive(Component, Default, Clone)]
+#[derive(Component, Debug, Default, Clone)]
 pub struct EffectsList {
     pub effects: Vec<ApplyStatus>,
 }
 
-#[derive(Clone)]
+#[derive(Clone, Debug)]
 pub enum StatusType {
     Burning(BurningStatus),
     Frozen,
@@ -20,7 +20,7 @@ pub enum StatusType {
     Stunned,
 }
 
-#[derive(Component, Clone)]
+#[derive(Component, Debug, Clone)]
 #[require(Status)]
 pub struct BurningStatus {
     pub damage: f32,
@@ -40,7 +40,7 @@ impl Default for BurningStatus {
 #[require(Status)]
 pub struct FrozenStatus;
 
-#[derive(Component, Clone)]
+#[derive(Component, Debug, Clone)]
 #[require(Status)]
 pub struct SlowedStatus {
     pub slow_percentage: f32,
diff --git a/src/combat/status_effects/events.rs b/src/combat/status_effects/events.rs
index 27a309e..b43a274 100644
--- a/src/combat/status_effects/events.rs
+++ b/src/combat/status_effects/events.rs
@@ -7,7 +7,7 @@ pub struct ApplyEffect {
     pub effect: Vec<ApplyStatus>,
 }
 
-#[derive(Event, Clone)]
+#[derive(Event, Debug, Clone)]
 pub struct ApplyStatus {
     pub status: StatusType,
     pub duration: f32,
diff --git a/src/combat/status_effects/status_systems/burning.rs b/src/combat/status_effects/status_systems/burning.rs
index 4239d6f..7be943d 100644
--- a/src/combat/status_effects/status_systems/burning.rs
+++ b/src/combat/status_effects/status_systems/burning.rs
@@ -1,9 +1,8 @@
 use bevy::prelude::*;
 
 use crate::combat::{
-    damage::{AttemptDamageEvent, Damage},
+    attributes::Health, damage::events::AttemptDamageEvent,
     status_effects::components::BurningStatus,
-    Health,
 };
 
 const RED_COLOR: bevy::prelude::Color = Color::srgb(1.0, 0.0, 0.0);
@@ -26,7 +25,7 @@ pub fn while_burning(
                 commands.trigger_targets(
                     AttemptDamageEvent {
                         damage_source: None,
-                        damage: Damage::Single(burn.damage),
+                        damage: burn.damage,
                     },
                     entity,
                 );
diff --git a/src/combat/status_effects/status_systems/slowed.rs b/src/combat/status_effects/status_systems/slowed.rs
index bc58f0a..17cda99 100644
--- a/src/combat/status_effects/status_systems/slowed.rs
+++ b/src/combat/status_effects/status_systems/slowed.rs
@@ -1,6 +1,6 @@
 use bevy::prelude::*;
 
-use crate::{ai::SimpleMotion, combat::status_effects::components::SlowedStatus};
+use crate::{combat::status_effects::components::SlowedStatus, movement::components::SimpleMotion};
 
 pub fn on_slow_applied(
     trigger: Trigger<OnInsert, SlowedStatus>,
diff --git a/src/combat/status_effects/status_systems/stunned.rs b/src/combat/status_effects/status_systems/stunned.rs
index b6b1cdc..20aa345 100644
--- a/src/combat/status_effects/status_systems/stunned.rs
+++ b/src/combat/status_effects/status_systems/stunned.rs
@@ -1,11 +1,11 @@
 use bevy::prelude::*;
 
 use crate::{
-    ai::SimpleMotion,
     combat::status_effects::{
         components::{SlowedStatus, StatusType, StunnedStatus},
         events::ApplyStatus,
     },
+    movement::components::SimpleMotion,
 };
 
 pub fn on_stun_applied(
diff --git a/src/combat/weapon/mod.rs b/src/combat/weapon/mod.rs
new file mode 100644
index 0000000..e22b3b2
--- /dev/null
+++ b/src/combat/weapon/mod.rs
@@ -0,0 +1 @@
+pub mod weapon;
diff --git a/src/combat/projectile/projectile_weapon.rs b/src/combat/weapon/weapon.rs
similarity index 88%
rename from src/combat/projectile/projectile_weapon.rs
rename to src/combat/weapon/weapon.rs
index 1ed78d7..1cfcea4 100644
--- a/src/combat/projectile/projectile_weapon.rs
+++ b/src/combat/weapon/weapon.rs
@@ -1,7 +1,7 @@
 use bevy::prelude::*;
 
 use crate::combat::projectile::components::ProjectileBundle;
-#[derive(Component)]
+#[derive(Component, Debug)]
 pub struct ProjectileWeapon {
     pub projectile: ProjectileBundle,
     pub projectile_speed: f32,
diff --git a/src/configuration/assets.rs b/src/configuration/assets.rs
index 755d7ff..7d6a520 100644
--- a/src/configuration/assets.rs
+++ b/src/configuration/assets.rs
@@ -39,7 +39,9 @@ pub struct SpriteSheetLayouts {
     ))]
     pub chest_layout: Handle<TextureAtlasLayout>,
     #[asset(texture_atlas_layout(tile_size_x = 100, tile_size_y = 100, columns = 10, rows = 1))]
-    pub tome_of_healing_effect: Handle<TextureAtlasLayout>,
+    pub spell_effect: Handle<TextureAtlasLayout>,
+    #[asset(texture_atlas_layout(tile_size_x = 32, tile_size_y = 32, columns = 4, rows = 1))]
+    pub shield_layout: Handle<TextureAtlasLayout>,
 }
 
 #[derive(AssetCollection, Resource)]
@@ -62,6 +64,10 @@ pub struct SpriteAssets {
     pub gold_coin: Handle<Image>,
     #[asset(path = "items/tome_of_healing.png")]
     pub tome_of_healing: Handle<Image>,
+    #[asset(path = "items/knight_shield.png")]
+    pub knight_shield: Handle<Image>,
+    #[asset(path = "items/magic_shield.png")]
+    pub magic_shield: Handle<Image>,
     #[asset(path = "items/sword.png")]
     pub sword: Handle<Image>,
     #[asset(path = "items/axe.png")]
@@ -96,6 +102,8 @@ pub struct SpriteAssets {
     pub chests_sprite_sheet: Handle<Image>,
     #[asset(path = "spells/tome_of_healing_effect.png")]
     pub tome_of_healing_effect_sprite_sheet: Handle<Image>,
+    #[asset(path = "spells/shield_effect.png")]
+    pub shield_effect_sprite_sheet: Handle<Image>,
     #[asset(path = "player/player_sprite_sheet.png")]
     pub player_sprite_sheet: Handle<Image>,
     #[asset(path = "enemies/ice_mage_enemy.png")]
diff --git a/src/configuration/plugins.rs b/src/configuration/plugins.rs
index 268d5c1..207f3d9 100644
--- a/src/configuration/plugins.rs
+++ b/src/configuration/plugins.rs
@@ -4,20 +4,22 @@ use bevy_ecs_tilemap::prelude::*;
 
 pub struct GamePlugins;
 
-use crate::{
-    ai::AIPlugin,
-    animation::AnimationPlugin,
-    combat::plugin::CombatPlugin,
-    configuration::{assets::AssetLoadingPlugin, schedule::SchedulePlugin, setup::SetupPlugin},
-    despawn::plugin::DespawnPlugin,
-    econ::plugin::EconPlugin,
-    enemy::plugin::EnemyPlugin,
-    items::{equipment::EquipmentPlugin, lootable::plugin::LootablePlugin},
-    map::plugin::MapPlugin,
-    npc::NPCPlugin,
-    player::plugin::PlayerPlugin,
-    progression::plugin::ProgressionPlugin,
-    ui::plugin::UIPlugin,
+use {
+    crate::animation::AnimationPlugin,
+    crate::combat::plugin::CombatPlugin,
+    crate::configuration::{
+        assets::AssetLoadingPlugin, schedule::SchedulePlugin, setup::SetupPlugin,
+    },
+    crate::despawn::plugin::DespawnPlugin,
+    crate::econ::plugin::EconPlugin,
+    crate::enemy::plugin::EnemyPlugin,
+    crate::items::{equipment::EquipmentPlugin, lootable::plugin::LootablePlugin},
+    crate::map::plugin::MapPlugin,
+    crate::movement::plugin::MovementPlugin,
+    crate::npc::NPCPlugin,
+    crate::player::plugin::PlayerPlugin,
+    crate::progression::plugin::ProgressionPlugin,
+    crate::ui::plugin::UIPlugin,
 };
 
 impl Plugin for GamePlugins {
@@ -30,7 +32,7 @@ impl Plugin for GamePlugins {
             // Core systems
             .add_plugins((
                 DespawnPlugin,
-                AIPlugin,
+                MovementPlugin,
                 CombatPlugin,
                 ProgressionPlugin,
                 EconPlugin,
diff --git a/src/enemy/components.rs b/src/enemy/components.rs
index 8e20917..d8c8afd 100644
--- a/src/enemy/components.rs
+++ b/src/enemy/components.rs
@@ -4,7 +4,7 @@ use avian2d::prelude::*;
 use bevy::prelude::*;
 use serde::Deserialize;
 
-use crate::{ai::SimpleMotion, combat::Health};
+use crate::{combat::attributes::health::Health, movement::components::SimpleMotion};
 
 //favoring #[require] as a default approach is generally recommended.
 #[derive(Component)]
diff --git a/src/enemy/systems/enemy_movement.rs b/src/enemy/systems/enemy_movement.rs
index 58c63cd..6e061c9 100644
--- a/src/enemy/systems/enemy_movement.rs
+++ b/src/enemy/systems/enemy_movement.rs
@@ -2,13 +2,13 @@ use bevy::prelude::*;
 use rand::{thread_rng, Rng};
 
 use crate::{
-    ai::{
-        state::{ActionState, AimPosition},
-        SimpleMotion,
+    combat::{
+        attributes::Health,
+        components::{ActionState, AimPosition},
     },
-    combat::Health,
     enemy::Enemy,
     items::equipment::EquipmentSlot,
+    movement::components::SimpleMotion,
     npc::NPC,
     player::{Player, UseEquipmentInputEvent},
 };
diff --git a/src/enemy/systems/enemy_spawn.rs b/src/enemy/systems/enemy_spawn.rs
index b215b72..3b35336 100644
--- a/src/enemy/systems/enemy_spawn.rs
+++ b/src/enemy/systems/enemy_spawn.rs
@@ -3,12 +3,11 @@ use bevy::prelude::*;
 use serde::Serialize;
 
 use crate::{
-    ai::{
-        state::{ActionState, AimPosition, FacingDirection},
-        SimpleMotion,
+    animation::{AnimationTimer, DefaultAnimationConfig, FacingDirection},
+    combat::{
+        attributes::{Health, Mana},
+        components::{ActionState, AimPosition},
     },
-    animation::{AnimationTimer, DefaultAnimationConfig},
-    combat::{Health, Mana},
     configuration::{
         assets::{SpriteAssets, SpriteSheetLayouts},
         GameCollisionLayer,
@@ -20,6 +19,7 @@ use crate::{
         spawn_health_potion, spawn_mainhand_weapon,
     },
     map::EnemiesSpawnEvent,
+    movement::components::SimpleMotion,
 };
 
 #[derive(Debug, Clone)]
diff --git a/src/enemy/systems/handle_enemy_defeated.rs b/src/enemy/systems/handle_enemy_defeated.rs
index de5a3cc..419c619 100644
--- a/src/enemy/systems/handle_enemy_defeated.rs
+++ b/src/enemy/systems/handle_enemy_defeated.rs
@@ -1,11 +1,11 @@
 use avian2d::prelude::ColliderDisabled;
 use bevy::prelude::*;
 
-use rand::{thread_rng, Rng};
-
 use crate::{
-    ai::state::ActionState,
-    combat::{damage::DefeatedEvent, invulnerable::Invulnerable},
+    combat::{
+        components::ActionState,
+        damage::{components::Invulnerable, events::DefeatedEvent},
+    },
     despawn::components::LiveDuration,
     econ::gold_drop::GoldDropEvent,
     enemy::{Enemy, Experience},
@@ -15,6 +15,7 @@ use crate::{
         PlayerStats,
     },
 };
+use rand::{thread_rng, Rng};
 
 pub fn on_enemy_defeated(
     trigger: Trigger<DefeatedEvent>,
diff --git a/src/items/components.rs b/src/items/components.rs
index 30d6486..02b6ef4 100644
--- a/src/items/components.rs
+++ b/src/items/components.rs
@@ -88,6 +88,8 @@ pub struct Magnet {
     pub strength: f32,
 }
 
+/* These components are both "offhand use effect definitions"
+but I'm not sure of a better home for them yet */
 #[derive(Component)]
 pub struct HealingTome {
     pub healing: (f32, f32),
@@ -99,3 +101,20 @@ pub struct HealingTome {
     LiveDuration(|| LiveDuration::new(1.0))
 )]
 pub struct HealingTomeSpellVisualEffect;
+
+#[derive(Component)]
+pub struct Shield {
+    pub hitbox: Collider,
+}
+
+//This component tags items that are active continiously while being used
+//e.g. Holding right will keep a shield up
+#[derive(Component)]
+pub struct Holdable;
+
+#[derive(Component)]
+#[require(
+    Visibility(|| Visibility::Visible),
+    LiveDuration(|| LiveDuration::new(5.0))
+)]
+pub struct ShieldSpellVisualEffect;
diff --git a/src/items/equipment/equip.rs b/src/items/equipment/equip.rs
index e920039..a24a5cb 100644
--- a/src/items/equipment/equip.rs
+++ b/src/items/equipment/equip.rs
@@ -1,7 +1,7 @@
 use bevy::prelude::*;
 
 use crate::{
-    combat::{damage::DamageSource, melee::MeleeWeapon},
+    combat::{damage::components::DamageSource, melee::components::MeleeWeapon},
     enemy::Enemy,
     items::inventory::Inventory,
 };
diff --git a/src/items/equipment/equipment_transform.rs b/src/items/equipment/equipment_transform.rs
index 08b958c..0ad755e 100644
--- a/src/items/equipment/equipment_transform.rs
+++ b/src/items/equipment/equipment_transform.rs
@@ -1,7 +1,6 @@
 use super::EquipmentSlot;
 use crate::{
-    ai::state::{ActionState, FacingDirection},
-    items::inventory::Inventory,
+    animation::FacingDirection, combat::components::ActionState, items::inventory::Inventory,
     labels::layer::ZLayer,
 };
 use bevy::prelude::*;
diff --git a/src/items/equipment/equippable.rs b/src/items/equipment/equippable.rs
index 87ea75f..b7ede01 100644
--- a/src/items/equipment/equippable.rs
+++ b/src/items/equipment/equippable.rs
@@ -40,9 +40,9 @@ impl Equippable {
     pub fn new(slot: EquipmentSlot) -> Self {
         Equippable { slot, ..default() }
     }
-    pub fn from(duration: f32, slot: EquipmentSlot) -> Self {
+    pub fn from(cooldown: f32, slot: EquipmentSlot) -> Self {
         Equippable {
-            use_rate: Timer::from_seconds(duration, TimerMode::Once),
+            use_rate: Timer::from_seconds(cooldown, TimerMode::Once),
             slot,
         }
     }
diff --git a/src/items/equipment/mod.rs b/src/items/equipment/mod.rs
index cb521ef..88043be 100644
--- a/src/items/equipment/mod.rs
+++ b/src/items/equipment/mod.rs
@@ -20,7 +20,10 @@ pub use use_equipped::UseEquipmentEvent;
 
 // Observers to be added to respective equipment/weapons that want this functionality
 pub use use_equipped::on_equipment_activated;
+pub use use_equipped::on_equipment_deactivated;
 pub use use_equipped::on_healing_tome_cast;
+pub use use_equipped::on_magic_shield_cast;
+pub use use_equipped::on_shield_block;
 pub use use_equipped::on_weapon_fired;
 pub use use_equipped::on_weapon_melee;
 
diff --git a/src/items/equipment/unequip.rs b/src/items/equipment/unequip.rs
index 067cf53..3b5b9f3 100644
--- a/src/items/equipment/unequip.rs
+++ b/src/items/equipment/unequip.rs
@@ -2,9 +2,9 @@ use avian2d::prelude::Collider;
 use bevy::prelude::*;
 
 use super::{equippable::Equipped, Equippable};
-use crate::{
-    ai::state::ActionState, combat::melee::ActiveMeleeAttack, items::inventory::Inventory,
-};
+use crate::combat::components::ActionState;
+use crate::combat::melee::components::ActiveMeleeAttack;
+use crate::items::inventory::Inventory;
 
 pub fn on_item_unequipped(
     trigger: Trigger<OnRemove, Equipped>,
diff --git a/src/items/equipment/use_equipped.rs b/src/items/equipment/use_equipped.rs
index cbc1b08..904d9fb 100644
--- a/src/items/equipment/use_equipped.rs
+++ b/src/items/equipment/use_equipped.rs
@@ -1,16 +1,24 @@
+use std::f32::consts::FRAC_PI_2;
+
 use bevy::prelude::*;
 use rand::Rng;
 
 use super::{EquipmentSlot, Equipped};
+use crate::animation::FacingDirection;
+use crate::combat::projectile::spawn::spawn_projectile_from_weapon;
+use crate::combat::shield::components::ProjectileReflection;
+use crate::combat::shield::shield_block::deactivate_shield;
+use crate::combat::shield::ActiveShield;
+use crate::items::{Shield, ShieldSpellVisualEffect};
+use crate::player::StopUsingHoldableEquipmentInputEvent;
 use crate::{
-    ai::state::{ActionState, AimPosition},
     combat::{
-        damage::DamageSource,
-        health::AttemptHealingEvent,
-        mana::ManaCost,
-        melee::{start_melee_attack, MeleeWeapon},
-        projectile::{spawn::spawn_projectile, ProjectileWeapon},
-        Mana,
+        attributes::{health::AttemptHealingEvent, mana::ManaCost, Mana},
+        components::{ActionState, AimPosition},
+        damage::components::DamageSource,
+        melee::{components::MeleeWeapon, swing_melee_attacks::start_melee_attack},
+        projectile::spawn::spawn_projectile,
+        weapon::weapon::ProjectileWeapon,
     },
     enemy::Enemy,
     items::{
@@ -34,7 +42,6 @@ pub enum EquipmentUseFailure {
 }
 
 #[derive(Event)]
-
 pub struct EquipmentUseFailedEvent {
     pub holder: Entity,
     pub slot: EquipmentSlot,
@@ -46,6 +53,7 @@ pub fn tick_equippable_use_rate(mut equippable_query: Query<&mut Equippable>, ti
         equippable.use_rate.tick(time.delta());
     }
 }
+
 pub fn on_equipment_activated(
     trigger: Trigger<UseEquipmentInputEvent>,
     commands: Commands,
@@ -106,7 +114,7 @@ fn handle_equipment_activation(
         // Check mana next
         if let (Some(mana), Some(mana_cost)) = (holder_mana.as_mut(), mana_cost) {
             if !mana.attempt_use_mana(mana_cost) {
-                warn!("Not enough mana!");
+                trace!("Not enough mana!");
                 commands.trigger_targets(
                     EquipmentUseFailedEvent {
                         holder: entity,
@@ -149,7 +157,7 @@ pub fn on_weapon_fired(
         return;
     };
 
-    spawn_projectile(
+    spawn_projectile_from_weapon(
         damage_source,
         &mut commands,
         holder_transform,
@@ -213,3 +221,55 @@ pub fn on_healing_tome_cast(
         .entity(fired_trigger.holder)
         .with_child(HealingTomeSpellVisualEffect);
 }
+
+pub fn on_magic_shield_cast(fired_trigger: Trigger<UseEquipmentEvent>, mut commands: Commands) {
+    commands
+        .entity(fired_trigger.holder)
+        .insert(ProjectileReflection);
+
+    commands
+        .entity(fired_trigger.holder)
+        .with_child(ShieldSpellVisualEffect);
+}
+
+pub fn on_shield_block(
+    fired_trigger: Trigger<UseEquipmentEvent>,
+    mut commands: Commands,
+    mut shield_query: Query<(Entity, &Shield)>,
+) {
+    let Ok((shield_entity, shield)) = shield_query.get_mut(fired_trigger.entity()) else {
+        warn!("Tried to block with invalid shield");
+        return;
+    };
+
+    commands.entity(shield_entity).insert(ActiveShield);
+}
+
+pub fn on_equipment_deactivated(
+    fired_trigger: Trigger<StopUsingHoldableEquipmentInputEvent>,
+    mut commands: Commands,
+    holder_query: Query<(&Inventory, &FacingDirection)>,
+    mut shield_query: Query<(Entity, &mut Sprite), (With<Shield>, With<ActiveShield>)>,
+) {
+    // Get the holder's inventory
+    let Ok((inventory, facing_direction)) = holder_query.get(fired_trigger.entity()) else {
+        warn!("Tried to stop blocking but entity has no inventory or no direction");
+        return;
+    };
+
+    let Some(shield_entity) = inventory.get_equipped(EquipmentSlot::Offhand) else {
+        warn!("No shield equipped in offhand");
+        return;
+    };
+
+    if let Ok((shield_entity, mut shield_sprite)) = shield_query.get_mut(shield_entity) {
+        deactivate_shield(
+            &mut commands,
+            shield_entity,
+            *facing_direction,
+            Some(&mut shield_sprite),
+        );
+    } else {
+        warn!("Shield is equipped but doesn't have ActiveShield");
+    }
+}
diff --git a/src/items/item_factory.rs b/src/items/item_factory.rs
index 4d4e628..8a6c6ba 100644
--- a/src/items/item_factory.rs
+++ b/src/items/item_factory.rs
@@ -1,7 +1,7 @@
 use bevy::prelude::*;
 
 use crate::{
-    ai::state::FacingDirection,
+    animation::FacingDirection,
     configuration::assets::SpriteAssets,
     items::{
         equipment::EquipmentTransform, Consumable, ConsumableEffect, ConsumableType, HealthPotion,
diff --git a/src/items/mainhand_factory.rs b/src/items/mainhand_factory.rs
index fc41777..c606dba 100644
--- a/src/items/mainhand_factory.rs
+++ b/src/items/mainhand_factory.rs
@@ -3,18 +3,16 @@ use bevy::prelude::*;
 use rand::{thread_rng, Rng};
 
 use crate::{
-    ai::state::FacingDirection,
+    animation::FacingDirection,
     combat::{
-        mana::ManaCost,
-        melee::{MeleeSwingType, MeleeWeapon},
-        projectile::{
-            components::{Projectile, ProjectileBundle},
-            ProjectileWeapon,
-        },
+        attributes::mana::ManaCost,
+        melee::components::{MeleeSwingType, MeleeWeapon},
+        projectile::components::{Projectile, ProjectileBundle},
         status_effects::{
             components::{BurningStatus, EffectsList, StatusType},
             events::ApplyStatus,
         },
+        weapon::weapon::ProjectileWeapon,
     },
     configuration::assets::{SpriteAssets, SpriteSheetLayouts},
     items::{
diff --git a/src/items/offhand_factory.rs b/src/items/offhand_factory.rs
index 4ef2aca..7a5047d 100644
--- a/src/items/offhand_factory.rs
+++ b/src/items/offhand_factory.rs
@@ -1,15 +1,23 @@
+use avian2d::prelude::Collider;
 use bevy::prelude::*;
 
-use super::{
-    equipment::{on_healing_tome_cast, EquipmentSlot},
-    HealingTome, Item, ItemType,
-};
-use crate::{
-    ai::state::FacingDirection,
-    combat::mana::ManaCost,
-    configuration::assets::SpriteAssets,
-    items::equipment::{EquipmentTransform, Equippable},
-};
+use super::equipment::on_healing_tome_cast;
+use super::equipment::on_shield_block;
+
+use super::equipment::EquipmentSlot;
+use super::HealingTome;
+use super::Holdable;
+use super::Item;
+use super::Shield;
+use super::ItemType;
+use crate::animation::FacingDirection;
+use crate::combat::attributes::mana::ManaCost;
+use crate::combat::attributes::ManaDrainRate;
+use crate::combat::shield::components::ProjectileReflection;
+use crate::configuration::assets::SpriteAssets;
+use crate::configuration::assets::SpriteSheetLayouts;
+use crate::items::equipment::EquipmentTransform;
+use crate::items::equipment::Equippable;
 
 fn spawn_tome_of_healing(commands: &mut Commands, sprites: &Res<SpriteAssets>) -> Entity {
     let offhand_transform: Transform = EquipmentTransform::get(FacingDirection::Down).offhand;
@@ -31,13 +39,83 @@ fn spawn_tome_of_healing(commands: &mut Commands, sprites: &Res<SpriteAssets>) -
         .id()
 }
 
+fn spawn_magic_shield(
+    commands: &mut Commands,
+    sprites: &Res<SpriteAssets>,
+    layouts: &Res<SpriteSheetLayouts>,
+) -> Entity {
+    let offhand_transform: Transform = EquipmentTransform::get(FacingDirection::Down).offhand;
+
+    commands
+        .spawn((
+            Name::new("Magic Shield"),
+            Item::new(6),
+            Equippable::from(0.5, EquipmentSlot::Offhand),
+            ManaCost(5.0),
+            ManaDrainRate(2.0),
+            ProjectileReflection,
+            Shield {
+                hitbox: Collider::rectangle(25.0, 25.0),
+            },
+            Holdable,
+            Visibility::Hidden,
+            Sprite {
+                image: sprites.magic_shield.clone(),
+                texture_atlas: Some(TextureAtlas {
+                    layout: layouts.shield_layout.clone(),
+                    index: 0,
+                }),
+                ..default()
+            },
+            offhand_transform,
+        ))
+        .observe(on_shield_block)
+        .id()
+}
+
+fn spawn_knight_shield(
+    commands: &mut Commands,
+    sprites: &Res<SpriteAssets>,
+    layouts: &Res<SpriteSheetLayouts>,
+) -> Entity {
+    let offhand_transform: Transform = EquipmentTransform::get(FacingDirection::Down).offhand;
+
+    commands
+        .spawn((
+            Name::new("Knight Shield"),
+            Item::new(6),
+            Equippable::from(0.5, EquipmentSlot::Offhand),
+            Shield {
+                hitbox: Collider::rectangle(25.0, 25.0),
+            },
+            ManaDrainRate(25.0),
+            ManaCost(25.0),
+            Holdable,
+            Visibility::Hidden,
+            Sprite {
+                image: sprites.knight_shield.clone(),
+                texture_atlas: Some(TextureAtlas {
+                    layout: layouts.shield_layout.clone(),
+                    index: 0,
+                }),
+                ..default()
+            },
+            offhand_transform,
+        ))
+        .observe(on_shield_block)
+        .id()
+}
+
 pub fn spawn_offhand(
     commands: &mut Commands,
     sprites: &Res<SpriteAssets>,
+    layouts: &Res<SpriteSheetLayouts>,
     offhand_name: &str,
 ) -> Entity {
     match offhand_name {
         "tome_of_healing" => spawn_tome_of_healing(commands, sprites),
-        _ => unreachable!(), // Should never happen
+        "magic_shield" => spawn_magic_shield(commands, sprites, layouts),
+        "knight_shield" => spawn_knight_shield(commands, sprites, layouts),
+        _ => unreachable!(),
     }
 }
diff --git a/src/lib.rs b/src/lib.rs
index 9d2be30..d225333 100644
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -1,5 +1,4 @@
 // Module declarations - keep these at the top
-pub mod ai;
 pub mod animation;
 pub mod combat;
 pub mod configuration;
@@ -9,6 +8,7 @@ pub mod enemy;
 pub mod items;
 pub mod labels;
 pub mod map;
+pub mod movement;
 pub mod npc;
 pub mod player;
 pub mod progression;
diff --git a/src/ai/simple_motion.rs b/src/movement/components.rs
similarity index 74%
rename from src/ai/simple_motion.rs
rename to src/movement/components.rs
index cec3a4c..f1f43f8 100644
--- a/src/ai/simple_motion.rs
+++ b/src/movement/components.rs
@@ -1,7 +1,6 @@
-use avian2d::prelude::LinearVelocity;
 use bevy::prelude::*;
 
-use crate::ai::state::FacingDirection;
+use crate::animation::FacingDirection;
 
 /// Simple motion has no acceleration and assumes all entities move at max speed unless altered by slowed_percentage
 /// by Movement
@@ -67,17 +66,3 @@ impl Default for SimpleMotion {
         SimpleMotion::new(10.0)
     }
 }
-
-/// Converts simulation motion into physics "real" motion (using avian linear velocity)
-pub fn to_velocity(mut query: Query<(&SimpleMotion, &mut LinearVelocity)>) {
-    for (motion, mut velocity) in query.iter_mut() {
-        if motion.is_moving() {
-            let temp_vel = motion.get_velocity();
-            velocity.x = temp_vel.x;
-            velocity.y = temp_vel.y;
-        } else {
-            velocity.x = 0.0;
-            velocity.y = 0.0;
-        }
-    }
-}
diff --git a/src/movement/mod.rs b/src/movement/mod.rs
new file mode 100644
index 0000000..27a445e
--- /dev/null
+++ b/src/movement/mod.rs
@@ -0,0 +1,3 @@
+pub mod components;
+mod motion;
+pub mod plugin;
diff --git a/src/movement/motion.rs b/src/movement/motion.rs
new file mode 100644
index 0000000..6c8bf64
--- /dev/null
+++ b/src/movement/motion.rs
@@ -0,0 +1,44 @@
+use avian2d::prelude::*;
+use bevy::prelude::*;
+
+use crate::{
+    animation::FacingDirection, combat::components::ActionState, movement::components::SimpleMotion,
+};
+
+pub fn simple_movement_to_velocity(mut query: Query<(&SimpleMotion, &mut LinearVelocity)>) {
+    for (motion, mut velocity) in query.iter_mut() {
+        if motion.is_moving() {
+            let temp_vel = motion.get_velocity();
+            velocity.x = temp_vel.x;
+            velocity.y = temp_vel.y;
+        } else {
+            velocity.x = 0.0;
+            velocity.y = 0.0;
+        }
+    }
+}
+
+pub fn update_facing_direction_and_action_state_on_motion_change(
+    mut query: Query<
+        (&SimpleMotion, &mut ActionState, &mut FacingDirection),
+        Changed<SimpleMotion>,
+    >,
+) {
+    for (motion, mut action_state, mut facing_direction) in query.iter_mut() {
+        facing_direction.set_if_neq(FacingDirection::from_vec2(
+            &facing_direction,
+            motion.direction,
+        ));
+
+        //Defeated and Attacking state take priority over walking / idle
+        if *action_state == ActionState::Attacking || *action_state == ActionState::Defeated {
+            continue;
+        } else {
+            if motion.is_moving() {
+                action_state.set_if_neq(ActionState::Movement);
+            } else {
+                action_state.set_if_neq(ActionState::Idle);
+            }
+        }
+    }
+}
diff --git a/src/movement/plugin.rs b/src/movement/plugin.rs
new file mode 100644
index 0000000..8b8761b
--- /dev/null
+++ b/src/movement/plugin.rs
@@ -0,0 +1,18 @@
+use bevy::prelude::*;
+
+use crate::{labels::sets::InGameSet, movement::motion::*};
+
+pub struct MovementPlugin;
+
+impl Plugin for MovementPlugin {
+    fn build(&self, app: &mut App) {
+        app.add_systems(
+            Update,
+            (
+                update_facing_direction_and_action_state_on_motion_change, //Handle idle to walking states here
+                simple_movement_to_velocity,
+            )
+                .in_set(InGameSet::Physics),
+        );
+    }
+}
diff --git a/src/npc/components.rs b/src/npc/components.rs
index 91b5375..f02cb0b 100644
--- a/src/npc/components.rs
+++ b/src/npc/components.rs
@@ -2,13 +2,13 @@ use avian2d::prelude::*;
 use bevy::prelude::*;
 
 use crate::{
-    ai::SimpleMotion,
-    combat::Health,
+    combat::attributes::Health,
     configuration::{
         assets::{SpriteAssets, SpriteSheetLayouts},
         GameCollisionLayer,
     },
     items::{spawn_axe, spawn_ice_staff, spawn_sword},
+    movement::components::SimpleMotion,
     player::interact::InteractionEvent,
 };
 
diff --git a/src/npc/movement.rs b/src/npc/movement.rs
index 03d7fb6..9702392 100644
--- a/src/npc/movement.rs
+++ b/src/npc/movement.rs
@@ -1,7 +1,7 @@
 use bevy::prelude::*;
 use rand::{thread_rng, Rng};
 
-use crate::{ai::SimpleMotion, enemy::Enemy, npc::components::NPC};
+use crate::{enemy::Enemy, movement::components::SimpleMotion, npc::components::NPC};
 
 #[derive(Component)]
 pub struct NPCWanderState {
diff --git a/src/npc/setup.rs b/src/npc/setup.rs
index fa5c7d5..d97a053 100644
--- a/src/npc/setup.rs
+++ b/src/npc/setup.rs
@@ -2,15 +2,12 @@ use avian2d::prelude::LockedAxes;
 use bevy::prelude::*;
 
 use crate::{
-    ai::{
-        state::{ActionState, FacingDirection},
-        SimpleMotion,
-    },
-    animation::{AnimationTimer, DefaultAnimationConfig},
-    combat::Health,
+    animation::{AnimationTimer, DefaultAnimationConfig, FacingDirection},
+    combat::{attributes::Health, components::ActionState},
     configuration::assets::{SpriteAssets, SpriteSheetLayouts},
     items::{equipment::Equipped, inventory::Inventory},
     map::NPCSpawnEvent,
+    movement::components::SimpleMotion,
     npc::components::NPC,
     player::interact::InteractionZone,
 };
diff --git a/src/player/animation/animation_setup.rs b/src/player/animation/animation_setup.rs
index bda8641..6732aaf 100644
--- a/src/player/animation/animation_setup.rs
+++ b/src/player/animation/animation_setup.rs
@@ -1,6 +1,6 @@
 use crate::{
-    ai::state::{ActionState, FacingDirection},
-    animation::{AnimationTimer, DefaultAnimationConfig},
+    animation::{AnimationTimer, DefaultAnimationConfig, FacingDirection},
+    combat::components::ActionState,
     configuration::assets::{SpriteAssets, SpriteSheetLayouts},
     player::Player,
 };
diff --git a/src/player/components/player.rs b/src/player/components/player.rs
index 9723fc5..08ede42 100644
--- a/src/player/components/player.rs
+++ b/src/player/components/player.rs
@@ -2,11 +2,8 @@ use avian2d::prelude::*;
 use bevy::prelude::*;
 
 use crate::{
-    ai::{
-        state::{ActionState, AimPosition, FacingDirection},
-        SimpleMotion,
-    },
-    combat::Health,
+    combat::{attributes::Health, components::AimPosition},
+    movement::components::SimpleMotion,
 };
 
 #[derive(Component)]
@@ -17,9 +14,7 @@ use crate::{
     PlayerLevel,
     AimPosition,
     RigidBody,
-    LockedAxes(|| LockedAxes::new().lock_rotation()),
-    FacingDirection,
-    ActionState,
+    LockedAxes(|| LockedAxes::new().lock_rotation())
 )]
 pub struct Player;
 
diff --git a/src/player/events.rs b/src/player/events.rs
index 3ea7808..36b567f 100644
--- a/src/player/events.rs
+++ b/src/player/events.rs
@@ -19,3 +19,8 @@ pub struct PlayerStoppedEvent;
 pub struct UseEquipmentInputEvent {
     pub slot: EquipmentSlot,
 }
+
+#[derive(Event)]
+pub struct StopUsingHoldableEquipmentInputEvent {
+    pub slot: EquipmentSlot,
+}
diff --git a/src/player/systems/consume.rs b/src/player/systems/consume.rs
index 4cce6a0..d0406df 100644
--- a/src/player/systems/consume.rs
+++ b/src/player/systems/consume.rs
@@ -1,5 +1,5 @@
 use crate::{
-    combat::health::AttemptHealingEvent,
+    combat::attributes::health::AttemptHealingEvent,
     items::{inventory::inventory::Inventory, ConsumableEffect, ConsumableType},
 };
 use bevy::prelude::*;
diff --git a/src/player/systems/cursor.rs b/src/player/systems/cursor.rs
index f9ebc44..227c877 100644
--- a/src/player/systems/cursor.rs
+++ b/src/player/systems/cursor.rs
@@ -2,7 +2,7 @@ use bevy::color::palettes::basic::WHITE;
 use bevy::prelude::*;
 use bevy::window::PrimaryWindow;
 
-use crate::ai::state::AimPosition;
+use crate::combat::components::AimPosition;
 use crate::player::Player;
 
 pub fn update_player_aim_position(
diff --git a/src/player/systems/death.rs b/src/player/systems/death.rs
index fed1504..3d1ed2e 100644
--- a/src/player/systems/death.rs
+++ b/src/player/systems/death.rs
@@ -1,10 +1,13 @@
 use bevy::prelude::*;
 
 use crate::{
-    ai::{state::ActionState, SimpleMotion},
-    combat::{damage::DefeatedEvent, invulnerable::Invulnerable},
+    combat::{
+        components::ActionState,
+        damage::{components::Invulnerable, events::DefeatedEvent},
+    },
     labels::states::{AppState, PlayingState},
     map::CleanupZone,
+    movement::components::SimpleMotion,
     player::Player,
 };
 
diff --git a/src/player/systems/input.rs b/src/player/systems/input.rs
index 68ff2d5..4df15f2 100644
--- a/src/player/systems/input.rs
+++ b/src/player/systems/input.rs
@@ -5,7 +5,7 @@ use crate::{
     labels::states::PausedState,
     player::{
         interact::PlayerInteractionInput, Player, PlayerMovementEvent, PlayerStoppedEvent,
-        UseEquipmentInputEvent,
+        StopUsingHoldableEquipmentInputEvent, UseEquipmentInputEvent,
     },
 };
 
@@ -16,9 +16,9 @@ pub struct PauseInputEvent {
 
 pub fn player_input(
     mut commands: Commands,
-    mut keyboard_input: ResMut<ButtonInput<KeyCode>>, // Access keyboard input
+    mut keyboard_input: ResMut<ButtonInput<KeyCode>>,
     buttons: Res<ButtonInput<MouseButton>>,
-    mut event_writer: EventWriter<PlayerMovementEvent>, // Dispatch movement events
+    mut event_writer: EventWriter<PlayerMovementEvent>,
     player_movement_query: Single<Entity, With<Player>>,
 ) {
     let player_entity = player_movement_query.into_inner();
@@ -44,7 +44,7 @@ pub fn player_input(
         );
     }
 
-    if buttons.pressed(MouseButton::Right) {
+    if buttons.just_pressed(MouseButton::Right) {
         commands.trigger_targets(
             UseEquipmentInputEvent {
                 slot: EquipmentSlot::Offhand,
@@ -53,6 +53,17 @@ pub fn player_input(
         );
     }
 
+    if buttons.just_released(MouseButton::Right) {
+        warn!("releasing MBR");
+        commands.trigger_targets(
+            StopUsingHoldableEquipmentInputEvent {
+                slot: EquipmentSlot::Offhand,
+            },
+            player_entity,
+        );
+        return;
+    }
+
     let mut direction = Vec2::ZERO;
 
     // Check input for movement and update direction
diff --git a/src/player/systems/movement.rs b/src/player/systems/movement.rs
index 39774ad..7ece8ec 100644
--- a/src/player/systems/movement.rs
+++ b/src/player/systems/movement.rs
@@ -1,8 +1,8 @@
 use bevy::prelude::*;
 
 use crate::{
-    ai::SimpleMotion,
     enemy::Enemy,
+    movement::components::SimpleMotion,
     npc::NPC,
     player::{Player, PlayerMovementEvent, PlayerStoppedEvent},
 };
diff --git a/src/player/systems/spawn_player.rs b/src/player/systems/spawn_player.rs
index 016ce14..7876e7c 100644
--- a/src/player/systems/spawn_player.rs
+++ b/src/player/systems/spawn_player.rs
@@ -4,13 +4,14 @@ use avian2d::prelude::*;
 use bevy::prelude::*;
 
 use crate::{
-    combat::{invulnerable::HasIFrames, Mana},
+    animation::FacingDirection,
+    combat::{attributes::mana::Mana, components::ActionState, damage::components::HasIFrames},
     configuration::{
         assets::{SpriteAssets, SpriteSheetLayouts},
         GameCollisionLayer,
     },
     items::{
-        equipment::{on_equipment_activated, Equipped},
+        equipment::{on_equipment_activated, on_equipment_deactivated, Equipped},
         inventory::Inventory,
         *,
     },
@@ -29,7 +30,9 @@ pub fn spawn_player(
         spawn_fire_staff(&mut commands, &sprites, &texture_layouts),
         spawn_health_potion(&mut commands, &sprites),
         spawn_sword(&mut commands, &sprites),
-        spawn_offhand(&mut commands, &sprites, "tome_of_healing"),
+        spawn_offhand(&mut commands, &sprites, &texture_layouts, "tome_of_healing"),
+        spawn_offhand(&mut commands, &sprites, &texture_layouts, "magic_shield"),
+        spawn_offhand(&mut commands, &sprites, &texture_layouts, "knight_shield"),
     ];
 
     let current_player_base_stats = PlayerStats::from(game_progress.base_stats);
@@ -59,11 +62,13 @@ pub fn spawn_player(
                     GameCollisionLayer::Magnet,
                 ],
             ),
+            (FacingDirection::Down, ActionState::Idle),
             Transform::from_xyz(0., 0., ZLayer::Player.z()),
         ))
         .add_children(&starting_items)
         .observe(death::on_player_defeated)
         .observe(on_equipment_activated)
+        .observe(on_equipment_deactivated)
         .id();
 
     commands
diff --git a/src/ui/damage_overlay.rs b/src/ui/damage_overlay.rs
index 9ab9696..ef65573 100644
--- a/src/ui/damage_overlay.rs
+++ b/src/ui/damage_overlay.rs
@@ -1,5 +1,5 @@
 use crate::{
-    combat::{damage::DamageDealtEvent, health::HealedEvent},
+    combat::{attributes::health::HealedEvent, damage::events::DamageDealtEvent},
     despawn::components::LiveDuration,
     labels::layer::ZLayer,
 };
diff --git a/src/ui/pause_menu/main_menu.rs b/src/ui/pause_menu/main_menu.rs
index 7e44ce8..0e4c2d4 100644
--- a/src/ui/pause_menu/main_menu.rs
+++ b/src/ui/pause_menu/main_menu.rs
@@ -1,5 +1,5 @@
 use crate::{
-    combat::Health,
+    combat::attributes::Health,
     items::inventory::Inventory,
     labels::states::PausedState,
     player::{Player, PlayerLevel},
@@ -38,7 +38,7 @@ pub fn spawn_main_menu(
     game_progress: Res<GameProgress>,
 ) {
     let (health, level, inventory) = player.into_inner();
-
+    debug!("spawn_main_menu called");
     commands
         .spawn((
             MainMenu,
diff --git a/src/ui/player_overlay.rs b/src/ui/player_overlay.rs
index 09b2072..5c187c7 100644
--- a/src/ui/player_overlay.rs
+++ b/src/ui/player_overlay.rs
@@ -1,7 +1,7 @@
 use bevy::prelude::*;
 
 use crate::{
-    combat::{Health, Mana},
+    combat::attributes::{Health, Mana},
     despawn::components::LiveDuration,
     items::{
         equipment::{
